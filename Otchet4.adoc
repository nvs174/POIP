:figure-caption: Рисунок
:table-caption: Таблица

include::Tityl_list_2.adoc[]

<<Цель отчета>>

<<Указатель>>

<<Ссылка>>

<<Вывод по работе>>

== Цель отчета

. Изучить что такое указатель
.. Как берется адресс и разыменоввывается указатель;
.. Модификаторы типов данных;
.. Виды операций над указателем;
.. Сложные указатели
.. Константный указатель и указатель на константу

. Что такое ссылка 

== Указатель

* Указатель это переменная, значением которой является адрес ячейки памяти. 

То есть указатель ссылается на блок данных из области памяти, причём на самое его начало. Указатель может ссылаться на переменную или функцию. Для этого нужно знать адрес переменной или функции.

Чтобы узнать адрес конкретной переменной в С++ существует унарная операция взятия адреса "&". Такая операция извлекает адрес объявленных переменных, для того, чтобы его присвоить указателю. 

.Пример:

[source, cpp]
----
int main() 
{
  int c = 463 ;
  int* ptr = &c ;
  return 0;
}
----
* [*] Объявляем переменную c типа int.

* [*] Объявляем указатель ptr на переменную c типа int.

* [*] Размер занимаемый указателя для микроконтроллера STM32F411RE равен  4 байтам или же 32 битам. 

* Взятие адреса и разыменование указателя это операция позволяющая получить объект, значение переменной по адресу, которая хранится в указателе.

.Пример:
[source, cpp]

----
int main() 
{
  int  c = 463 ;              
  int* ptr = &c ;             
  cout << &c ;                
  cout << c ;                 

  *ptr = 5;                   
  cout << c << ": " << *ptr;  
}
----
Где через выражение *ptr мы можем получить значение по адресу, который хранится в указателе ptr, а через выражение типа *ptr = 5 значение вложить по этому адресу новое значение.

* Операции над указателями

С указателями можно выполнять следующие операции: 

* [*] Разадресация *; 

* [*] Присваивание; 

* [*] Сложение с константой; 

* [*] Вычитание;

* [*] Инкремент (++); 

* [*] Декремент (--); 

* [*] Сравнение; 

* [*] Приведение типов;

* [*] Операции с  получением адреса (&).

Но указатели должны быть одинковых типов данных.

.Пример:

[source, cpp]
----

int main() {
  int  c = 463 ;              
  int* ptr = &c ;             
  cout << &c ;                
  cout << c ;                 

  *ptr = 5;                   
  cout << c << ": " << *ptr;  
}
----

 . Где объявление массива "arr" из 5 элементов. В целом можно считать, что данный массив это указатель на первый элемент массива.

. Обявляется указатель на массив типа int.

. Далее происходит увеличивание указатель на 1. Но на самом деле происходит смещение по адресам на размер равный size_of(int) на 4 байта. Указатель "ptr" стал указывать на элемент массива arr[1].

. Объявляем переменную "а" типа int и присваиваем ей значение "аrr[4]"".

. Сравнение указателя с nullptr указателем.
. Вывод значения "а" и значения по адресу в указателе "ptr".

* Сложение указателей

Сложение указателей - эта вохзможность прибавить целое число к указателю, целое значение числа будет преобразовано с помощью его умножения на размер значения, к которому обращается указатель. После преобразования значение целого числа представляет позиции памяти, где каждая позиция имеет длину, заданную типом указателя.

.Пример:

[source, cpp]
----
int main() 
{
  int  arr[] = {1,2,3,4,5} ;    
  int* ptr = arr ;              

  ptr ++ ;                      
  int a = *(ptr + 3) ;
}
----
 . Объявление массива arr из 5 элементов. В целом можно считать, что массив arr это указатель на первый элемент массива.

. Обявления указателя на массив типа int.

. Увеличиваем указатель на 1. На самом деле мы смещаемся по адресам на размер равный size_of(int), т.е. на 4 байта. Т.е в данном случае указатель ptr стал указывать на элемент массива arr[1].

. Записываем в переменную а типа int данные, находящиеся по адресу, хранящиеся в
указателе ptr, смещенном на 3.



.Константный указатель и указатель на константу


* [*] Константный указатель — это указатель, значение которого не может быть изменено после инициализации. Для объявления константного указателя используется ключевое слово const между звёздочкой и именем указателя.

* [*] Константный указатель всегда указывает на один и тот же адрес, и этот адрес не может быть изменен.


[source, cpp]
----
int main() 
{
  const auto pi[] = {3.14, 3.14159} ;
  const double *ptr = pi ;
  *ptr = 3.14159 ;                  
  ptr++ ;                           
  count << *ptr ;                   
  const double * const ptr1 = pi ;  
  ptr1++  ;                         
  retrun 0 ;
}
----

. Пытаемся поменять значение по указателю ptr (pi[0]). Ошибка, указатель на константу, нельзя поменять значение константы

. Увеличиваем указатель на 1 (теперь указатель указывает на p[1]).

. Вывод значения по указателю (3.14159)

. Объявляем константный указатель на константу

. Нельзя изменить указатель, он константный

== Ссылка

* [*] Ссылка - это альтернативное имя объекта.

Ссылку можно понимать как безопасный вариант указателя. При этом ссылки имеют особенности, отличающие их от указателей:

. При объявлении ссылка обязательно  на уже существующий объект данного типа. Ссылка не может ссылаться "ни на что".

. Ссылка от её объявления до её исчезновения указывает на один и тот же адрес.

. При обращении к ссылке разыменование происходит автоматически.

. Адрес ссылки — это адрес исходного объекта, на который она указывает.

Объявление ссылок очень похоже на объявление указателей, только вместо звёздочки "*" пишется амперсанд "&".
При объявлении ссылка обязана быть инициализирована.

.Пример:
[source, cpp]
----
int main()
{
  int a = 0;
  int &ref = a ;                
  ref = 10;                     
  cout << &ref << ": " << ref ; 
  return 0 ;
}
----

. Объявляем ссылку на переменную "а".

. Записываем в переменную "а" число 10.

. Выводим адрес перменной "а" и значение переменной "a".


== Вывод по работе

Изучено:

* [*] Указатель 

* [*] Взятие адреса и разыменование указателя;

* [*] Операции над указателями;

* [*] Сложение указателей;

* [*] Константный указатель и указатель на константу;

* [*]  Ссылка.





