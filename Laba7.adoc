:figure-caption: Рисунок
:table-caption: Таблица

include::Tityl_list_3.adoc[lines=1..10]
[.text-right]

Лабораторная работа 7
include::Tityl_list_3.adoc[lines="12..25"]


<<Цель отчета>>

<<Что такое таймер>>

<<Настройка таймер TIM5>>

<<Программа с таймером TIM5>>

<<Вывод по работе>>

== Цель отчета

. Изучить что такое таймер 

. Настройка таймер TIM5

. Написать программу, где задержка изменения состояние светодиода реализована через TIM5

== Что такое таймер

* [*] Таймер микроконтроллера – это цифровой счётчик, осуществляющий подсчёт количества подаваемых на него импульсов. Источником импульсов для таймера-счётчика могут служить: как тактовые импульсы от внутреннего генератора МК, так и импульсы, подаваемые непосредственно на вход таймера с внешнего источника.

Таймеры нужны для точного отсчета времени, измерения частоты/периода, генерации ШИМ (широтно-импульсной модуляции) и переменных сигналов. Всего есть следующие виды таймеров:

. SYSTEM TIMER. Также существуют системный таймер SysTick таймер и Watchdog таймер.

. Расширенный 16 битный таймер автоматической перезагрузки, приводимого в действие программируемым прескалером.

. 16-разрядные или 32-разрядные таймеры общего назначения автоматической перезагрузки, приводимого в действие программируемым прескалером.

В работе будет использоваться таймер TIM5:

* [*] Таймер 32 битный, может считать до 2^32, умеет работать с инкрементальными энкодерами и датчиками Холла;

== Настройка таймер TIM5
Для организации задержки таймера TIM5 нужно выполнить следующие:

. Подать тактирование на модуль таймера​

. Установить делитель частоты для таймера в регистре PSC​

. Установить источник генерации прерываний по событию переполнение с помощью бита URS в регистре CR1​

. Установить значение до которого счетчик будет считать в регистре перезагрузке ARR​

. Скинуть флаг генерации прерывания UIF по событию в регистре SR​

. Установить начальное значение счетчика в 0 в регистре CNT​

. Запустить счетчик с помощью бита EN в регистре CR1​

. Проверять, пока не будет установлен флаг генерации прерывания по событию UIF в регистре SR​

. Как только флаг установлен, остановить счетчик, сбросить бит EN в регистре CR1. Сбросить флаг генерации прерывания UIF по событию в регистре SR


== Программа с таймером TIM5

[source, cpp]
---- 
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOэ
#include "Pin3.h"
#include "PinAll.h"
#include "Treemode.h"
#include "ChMode.h"
#include "Gerland.h"
#include "AllMode.h"
#include "Button2.h"
#include <array>
#include "stkregisters.hpp"
#include "scbregisters.hpp"
#include "tim5registers.hpp"


std::uint32_t SystemCoreClock = 8'000'000U;

std::uint32_t Tim5 = 1'000'000U;

using tMec = std::uint32_t;


extern "C" {
int __low_level_init(void)
{
RCC::APB1ENR::TIM5EN::Enable::Set();
return 1;
}
}

using tMsec = std::uint32_t;

void delay(tMsec period)
{
const auto timerValue = static_cast<uint32_t>(((period)*(Tim5/1000U))-1U);
TIM5::PSC::Write(15); 
TIM5::CR1::URS::Value1::Set(); 
TIM5::ARR::Write(timerValue); 
TIM5::SR::UIF::Set(0); 
TIM5::CNT::Write(0); 

TIM5::CR1::CEN::Enable::Set(); 
while(TIM5::SR::UIF::Get() == 0) 
{
}
TIM5::CR1::CEN::Disable::Set(); 
TIM5::SR::UIF::Set(0); 
}


Pin<GPIOA, 5>  pin1;
Pin<GPIOC, 9>  pin2;
Pin<GPIOC, 8>  pin3;
Pin<GPIOC, 5>  pin4;

Button<GPIOC, 13> btn;

AllMode<pin1, pin2, pin3, pin4> allMode;
TreeMode<pin1,pin2, pin3, pin4> treemode;
ChessMode<pin1,pin2, pin3, pin4> chessmode;

Gerland<allMode,treemode, chessmode> gerland;

int main()
{

  RCC::APB1ENR::TIM5EN::Enable::Set();  
  // Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  // Подать тактирование на порт А
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  // Порт  А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  // Порта С.5,С.8,С.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  
  GPIOC::MODER::MODER13::Input::Set();
 
  tMec i = 500U;
  for(;;)
  {
    gerland.Update();
    if(btn.IsPressed())
    {
      i = (i<tMsec(1000)) ? (i+tMsec(100U)) : tMsec(500U) ;
    }
    delay(i);
    
     }
  
  return 1;
}
----

== Вывод по работе

* [*] Изучено что такое таймер 

* [*] Выполнена настройка таймер TIM5

* [*] Написана программа, где задержка изменения состояние светодиода реализована через TIM5, переключения светодиодов выполянется каждые 500 мс, каждое нажате кнопки увеличивает время переключения на 100 мс, при достижении более 1000 мс, период становиться 500 мс.