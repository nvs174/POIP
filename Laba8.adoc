:figure-caption: Рисунок
:table-caption: Таблица

include::Tityl_list_3.adoc[lines=1..10]
[.text-right]

Лабораторная работа 8
include::Tityl_list_3.adoc[lines="12..25"]


<<Цель отчета>>

<<Программа>>

<<Вывод по работе>>

== Цель отчета

. Настроить таймер TIM2 - таймер будет увеличивать период 

. Настроить таймер TIM5 - таймер отвечает за прерывание по кнопки



== Программа 

.Лисинг main.cpp 
[source, cpp]
---- 
#include "rccregisters.hpp"     // for RCC
#include "gpioaregisters.hpp"   // for GPIOA
#include "gpiocregisters.hpp"   // for GPIOC
#include "Pin3.h"               // for pin
#include "Treemode.h"           // for metod pins
#include "ChMode.h"             // for metod pins
#include "Gerland.h"            // for metod pins
#include "AllMode.h"            // for metod pins
#include "Button2.h"            // for button

#include "stkregisters.hpp" // for STK
#include "scbregisters.hpp" // for ICSR
#include "tim2registers.hpp" // for TIM2
#include "tim5registers.hpp" // for TIM5
#include "nvicregisters.hpp" // for NVIC
#include "allflickmode.h" // for AllFlickMode




std::uint32_t SystemCoreClock = 8'000'000U;


using tMec = std::uint32_t;

tMec period = 500U;



extern "C" {
int __low_level_init(void)
{
  RCC::APB1ENR::TIM2EN::Enable::Set();
    RCC::APB1ENR::TIM5EN::Enable::Set();

    NVIC::ISER0::Write(1 << 28U); // разрешили глобальное прерывание для TIM2

    TIM2::PSC::Write(15999U);
    TIM2::CR1::URS::OverflowEvent::Set();
    TIM2::ARR::Write(500U);
    TIM2::SR::UIF::Set(0);
    TIM2::CNT::Write(0);
    TIM2::DIER::UIE::Enable::Set(); // разрешили прерывание по переполнению

    NVIC::ISER1::Write(1 << 18U); // разрешили глобальное прерывание для TIM5

    TIM5::PSC::Write(15999U);
    TIM5::CR1::URS::Value1::Set();
    TIM5::ARR::Write(100U);
    TIM5::SR::UIF::Set(0);
    TIM5::CNT::Write(0);
    TIM5::DIER::UIE::Value1::Set(); // разрешили прерывание по переполнению
    return 1;
}
}



void SetTimerPeriod(tMec period)
{
  TIM2::ARR::Write(period);
}



Pin<GPIOA, 5>  pin1;
Pin<GPIOC, 9>  pin2;
Pin<GPIOC, 8>  pin3;
Pin<GPIOC, 5>  pin4;

AllFlickMode<pin1, pin2, pin3, pin4> allflickMode;

AllMode<pin1, pin2, pin3, pin4> allMode;
TreeMode<pin1,pin2, pin3, pin4> treemode;
ChessMode<pin1,pin2, pin3, pin4> chessmode;

Gerland<allMode,treemode, chessmode> gerland;

Button<GPIOC, 13> button;

int main()
{
  RCC::APB1ENR::TIM5EN::Enable::Set();  
  // Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  // Подать тактирование на порт А
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  // Порт  А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  // Порта С.5,С.8,С.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  TIM2::CR1::CEN::Enable::Set();
  TIM5::CR1::CEN::Enable::Set();
  
  
 
  for(;;)
  {
    if(allflickMode.CheckForUpdate())
    {
      allflickMode.Update();
      allflickMode.SetFlag(false);
    }
    if(button.CheckForUpdate())
    {
      period = (period<tMec(1000)) ? (period+tMec(100U)) : tMec(500U) ;
       button.SetFlag(false);
       SetTimerPeriod(period);
    }
  }
    
}
----

.Лисинг timersconfig.h

[source, cpp]
----
#ifndef TIMERSCONFIG
#define TIMERSCONFIG

#include "timer2.h" // for Timer2
#include "timer5.h" // for Timer5
#include "Pin3.h" // for pin.h
#include "allflickmode.h" // for AllFlickMode
#include "Button2.h" // for button
#include "gpiocregisters.hpp" // for GPIOC
#include "gpioaregisters.hpp" // for GPIOA

extern Pin<GPIOA,5> pin1 ;
extern Pin<GPIOC,9> pin2 ;
extern Pin<GPIOC,8> pin3 ;
extern Pin<GPIOC,5> pin4 ;

extern Button<GPIOC, 13> button;
extern AllFlickMode<pin1, pin2, pin3, pin4> allflickMode;

using tTimer2 = Timer2<allflickMode>;
using tTimer5 = Timer5<button>;

#endif
----



.Лисинг timer5.h

[source, cpp]
----
#ifndef TIMER5
#define TIMER5

#include "tim5registers.hpp" //for TIM5

template <auto& button>
class Timer5
{
public:
  static void handler()
  {
    if(TIM5::SR::UIF::InterruptPending::IsSet() and TIM5::DIER::UIE::Value1::IsSet())
    {
      if(button.IsPressed())
      {
        button.SetFlag(true);
      }
      TIM5::SR::UIF::NoInterruptPending::Set();
    }
  }
};
#endif
----





.Лисинг timer2.h

[source, cpp]
----
#ifndef TIMER2
#define TIMER2

#include "tim2registers.hpp" //for TIM2

template <auto& allflickMode>
class Timer2
{
public:
  static void handler()
  {
    if(TIM2::SR::UIF::InterruptPending::IsSet() and TIM2::DIER::UIE::Enable::IsSet())
    {
      allflickMode.SetFlag(true);
      TIM2::SR::UIF::NoInterruptPending::Set();
    }
  }
};
#endif
----




.Лисинг button.h

[source, cpp]
----
#ifndef BUTTON
#define BUTTON
#include "IButton.h"
#include "Gerland.h"
#include <array>

template<typename Port, int pinNumber>
class Button : public IButton
{
public:
  bool IsPressed() override   
  {
     if(((Port::IDR::Get()&(1 << pinNumber))==0) && (isSet))
  {
    isSet = false;
  } else if(((Port::IDR::Get()&(1 << pinNumber))==(1 << pinNumber)) && (!isSet))
  {
    isSet = true;
    return true;
  }
  return 0;
    
  }
  
  bool CheckForUpdate()
  {
    return Flag;
  }
  bool SetFlag(bool flag)
  {
    Flag = flag;
  }
  
private:
  bool isSet = true;
  bool Flag = false;
};
#endif
----


.Лисинг allflickmode.h

[source, cpp]
----
#ifndef ALLFLICKMODE
#define ALLFLICKMODE

#include "Mode.h"
#include <array>


template <auto& ... pins>
class AllFlickMode: public Mode
{
public:
  void Update() override
  {
    for(std::size_t i = 0; i < leds.size(); i++)
    {
      leds[i]->Toggle();
    }
  }
  void Clear() override 
  {
   
    for (int i = 0; i<leds.size(); ++i) 
    {
      leds[i]->LedSetLow();
    
    }
  }
  bool CheckForUpdate()
  {
    return Flag;
  }
  bool SetFlag(bool flag)
  {
    Flag = flag;
  }
private:
  bool Flag = false;
  std::array<Ipin*, sizeof ...(pins)> leds = {&pins...};
};
#endif
----






== Вывод по работе

* [*] Выполнена настройка таймер TIM2.

* [*] Выполнена настройка таймер TIM5.

* [*] Написана программа, где задержка изменения состояние светодиода реализована через TIM2, переключения светодиодов выполянется каждые 500 мс, каждое нажате кнопки увеличивает время переключения на 100 мс, при достижении более 1000 мс, период становиться 500 мс.

* [*] Знаниям, полученные в этой работе по настройке и использованию нескольких таймеров потребуется в дальнейшем изучении и работе с отладочной платой STM32F411RE.