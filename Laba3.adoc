:figure-caption: Рисунок
:table-caption: Таблица

include::Tityl_list_3.adoc[lines=1..10]
[.text-right]

Лабораторная работа 3
include::Tityl_list_3.adoc[lines="12..25"]


<<Цель отчета>>

<<Унарный плюс>>

<<Запятая>>

<<Настройка тактирования>>

<<Вывод по работе>>

== Цель отчета

. Изучить свойства унарного плюса 
. Изучить свойства запятой ''
. Настроить модуль тактирования на частоту 32 МГц от внутреннего высокочастотного RC-генератора 16 МГц  

== Унарный плюс

Результатом унарного оператора плюса (+) является значение его операнда. Операнд оператора унарного оператора сложения должен иметь арифметический тип. 
Унарный оператор + может изменяет размер переменной

* Пример:
[source, cpp]
----
int main() 
{
 unsigned short x = 5;
printf ("%d\n",sizeof(+x));
printf ("%d\n",sizeof(x));
return 0;
}
----

.Результат работы кода
image::Picter/Picter_3.png[]

 * [*] Результат работы меняет размер unsigned short (2 байта) на размер в 4 байта .

== Запятая

Оператор запятая (,) позволяет объединить несколько выражений в одно выражение, таким образом в C++ вводится понятие выражение с запятой, имеющее общий вид записи:< выражение>, <выражение>, <выражение>.

Оператор «запятая» вызывает выполнение последовательности действий. Когда он используется с правой стороны оператора присваивания, то присваиваться будет значение последнего выражения, стоящего в разделенном запятыми списке.

* Пример:


[source, cpp]
----
int main() 
{
  int y = 10;
  int x;
  x = (y = y - 5, 25 / y);
  printf("%d", x);
  return 1;
}
----

.Результат работы кода
image::Picter/Picter_4.png[]

* [*] После выполнения х получит значение 5, поскольку исходным значением у было 10, а затем оно уменьшилось на 5. Затем 25 поделили на полученное 5 и получили результат.

* [*] Об операторе «запятая» следует думать как об обычном слове «и» в нормальном русском языке, когда оно используется в выражении «сделай это, и это, и это».


== Настройка тактирования

Система ФАПЧ (PLL) – набор из умножителей и делителей,исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.​

Для подачи на модуль тактирования соответсвующей частоты, в данном случае 32 МГц, нужно использовать поля PLLM, PLLN, PLLP. PLLQ нужен для подачи частоты для интерфейса USB.

Регистр имеет поля различной длины

* [*] PLLM (2 ≤ PLLM ≤ 63), 
* [*] PLLN ( 50 ≤ PLLN ≤ 432), 
* [*] PLLP (PLLP = 2, 4, 6, or 8), 
* [*] PLLQ (2 ≤ PLLQ ≤ 15)

Так же есть поле PLLSRC, оно отвечает за то, с какого генератора будет подаваться входной сигнал.

Формула, по которой расчитывается системная тактовая частота с изпользованием ФАПЧ:

* [*] F = F(PLL clock input) × (PLLN / PLLM) / PLLP​

Используя данную формулу, нужно подобрать только соответствующие коэффициенты. Можно взять следующие коэффициенты: 

* [*] PLLN = 128, 
* [*] PLLM = 8, 
* [*] PLLP = 8.

* Код программы:


[source, cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOэ

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
  RCC::CR::HSION::On::Set();
 
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  
  *reinterpret_cast<std::uint32_t*>(0x40023804) &= 0;
  RCC::PLLCFGR::PLLSRC::HsiSource::Set();
    RCC::PLLCFGR::write(1U << 16U);
  RCC::PLLCFGR::write(1U << 17U);
  RCC::PLLCFGR::write(1U << 3U);
  RCC::PLLCFGR::write(1U << 13U);
  RCC::CR::PLLON::On::Set();
  while (RCC::CR::PLLRDY::Unclocked::IsSet())
  {
    
  }
  RCC::CFGR::SW::Pll::Set();
  while (!RCC::CFGR::SWS::Pll::IsSet())
  {
    
  }
  RCC::CR::HSION::Off::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {   
    asm volatile("");
  }    
}

int main()
{  
  // Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  // Подать тактирование на порт А
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  // Порт  А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  // Порта С.5,С.8,С.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
   
  std::uint32_t* Port_A = reinterpret_cast<std::uint32_t*>(0x40020014);
  
  std::uint32_t* Port_C = reinterpret_cast<std::uint32_t*>(0x40020814);
  for(;;)
  {
    *Port_A ^= 0x20;   
    
    *Port_C ^= 0x320;
  
    delay(1000000); 
    
  }
  
  return 1;
}
----




== Вывод по работе

Изучено:

* [*] Свойства унарного плюса;

* [*] Свойства запятой '';

* [*] Произведена настроить модуль тактирования на частоту 32 МГц от внутреннего высокочастотного RC-генератора 16 МГц 
